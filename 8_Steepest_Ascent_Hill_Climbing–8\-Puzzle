import random

goal = ((1,2,3),
        (4,5,6),
        (7,8,0))



def misplaced_tiles(state):
    count = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0 and state[i][j] != goal[i][j]:
                count += 1
    return count



def manhattan(state):
    distance = 0
    for i in range(3):
        for j in range(3):
            value = state[i][j]
            if value != 0:
                goal_x = (value - 1) // 3
                goal_y = (value - 1) % 3
                distance += abs(goal_x - i) + abs(goal_y - j)
    return distance


def get_neighbors(state):
    neighbors = []
    state = [list(row) for row in state]

    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                x, y = i, j

    moves = [(1,0), (-1,0), (0,1), (0,-1)]

    for dx, dy in moves:
        nx, ny = x+dx, y+dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append(tuple(tuple(row) for row in new_state))

    return neighbors


def hill_climbing(start, heuristic):
    current = start

    while True:
        neighbors = get_neighbors(current)
        current_h = heuristic(current)

        best = current
        best_h = current_h

        for neighbor in neighbors:
            h = heuristic(neighbor)
            if h < best_h:
                best = neighbor
                best_h = h

        if best_h >= current_h:
            return current  # Local optimum reached

        current = best


start_state = ((1,2,3),
               (4,0,6),
               (7,5,8))

print("Hill Climbing Result:",
      hill_climbing(start_state, manhattan))
